<?php
// $Id$

/**
 * Implementation of hook_help().
 */
function skinr_help($path, $arg) {
  switch ($path) {
    case 'admin/help#skinr':
      return t('Please refer to <a class="ext" href="http://drupal.org/node/578552">@skinr introduction </a> and <a class="ext" href="http://drupal.org/node/578574">documentation</a>.', array('@skinr' => 'Skinr'));
      break;
  }
}

/**
 * Implementation of hook_init().
 */
function skinr_init() {
  module_load_include('inc', 'skinr', 'skinr.handlers');
  skinr_module_include('skinr.inc');
}

/**
 * Implementation of hook_preprocess().
 */
function skinr_preprocess(&$variables, $hook) {
  $skinr_config = skinr_fetch_config();
  $info = skinr_skin_data();
  $current_theme = skinr_current_theme();
  $theme_registry = theme_get_registry();

  // Add any base themes.
  $themes_info = list_themes();
  $themes = isset($themes_info[$current_theme]->base_themes) ? $themes_info[$current_theme]->base_themes : array();
  // Add the current theme.
  $themes[] = $current_theme;

  $original_hook = $hook;
  if (isset($theme_registry[$hook]['original hook'])) {
    $original_hook = $theme_registry[$hook]['original hook'];
  }

  foreach ($skinr_config as $module => $settings) {
    if (!empty($settings['preprocess'][$original_hook])) {
      $preprocess_settings = $settings['preprocess'][$original_hook];
      $sid = skinr_handler('preprocess_index_handler', 'preprocess', $preprocess_settings['index_handler'], $variables);

      $style = array();
      if (!empty($sid)) {
        if (is_array($sid)) {
          foreach ($sid as $sub_sid) {
            if ($skinr = skinr_get(NULL, $module, $sub_sid)) {
              $style = $skinr->skins + $style;
            }
          }
        }
        else {
          if ($skinr = skinr_get(NULL, $module, $sid)) {
            $style = $skinr->skins;
          }
        }

        // Allow other modules to alter the skinr style array.
        // @todo: D7 Fix required!
        drupal_alter('skinr_skins', $style, $module, $sid, $settings);

        foreach ($style as $skin => $classes) {
          // Add custom CSS files.
          if (!empty($info[$current_theme]['skins'][$skin]['stylesheets'])) {
            foreach ($info[$current_theme]['skins'][$skin]['stylesheets'] as $media => $stylesheets) {
              foreach ($stylesheets as $stylesheet) {
                _skinr_add_file($stylesheet, $themes, 'css', $media);
              }
            }
          }

          // Add custom JS files.
          if (isset($info[$current_theme]['skins'][$skin]['scripts'])) {
            foreach ($info[$current_theme]['skins'][$skin]['scripts'] as $script) {
              _skinr_add_file($script, $themes, 'js');
            }
          }
        }

        // Add template files.
        if (!empty($style['_template'])) {
          $variables['theme_hook_suggestions'][] = $style['_template'];
          unset($style['_template']);
        }

        $variables['skinr'] = skinr_style_flatten_array($style);
        $variables['classes_array'] = array_merge($variables['classes_array'], $variables['skinr']);
      }
    }
  }
}

/**
 * Helper fuction to add CSS and JS files.
 *
 * The function checks an array of paths for the existence of the file to account for base themes.
 */
function _skinr_add_file($filename, $themes, $type, $media = NULL) {
  if (!is_array($themes)) {
    $themes = array($themes);
  }

  foreach ($themes as $theme) {
    if (file_exists($filename)) {
      if ($type == 'css') {
        drupal_add_css($filename, array('weight' => CSS_THEME, 'media' => $media));
      }
      else {
        drupal_add_js($filename, array('weight' => JS_THEME));
      }
      break;
    }
  }
}

/**
 * Helper function to flatten an array of classes settings.
 */
function skinr_style_flatten_array($style) {
  $return = array();
  foreach ($style as $entry) {
    if (is_array($entry)) {
      foreach ($entry as $subentry) {
        if (!empty($subentry)) {
          $return[] = check_plain($subentry);
        }
      }
    }
    elseif (!empty($entry)) {
      $return[] = check_plain($entry);
    }
  }

  return $return;
}

// ------------------------------------------------------------------
// Page rule functions.

/**
 * Save a skinr page rule object.
 */
function skinr_rule_save($rule) {
  drupal_write_record('skinr_rules', $rule, !empty($rule->rid) ? array('rid') : array());
  return $rule->rid;
}

/**
 * Load a skinr page rule object.
 */
function skinr_rule_load($rid = NULL) {
  if (is_null($rid)) {
    $rules = array();

    $result = db_query("SELECT * FROM {skinr_rules}");
    foreach ($result as $rule) {
      $rule->roles = unserialize($rule->roles);
      $rules[] = $rule;
    }

    return $rules;
  }
  else {
    $rule = db_query("SELECT * FROM {skinr_rules} WHERE rid = :rid", array(
      ':rid' => $rid,
    ))->fetchObject();
    if ($rule) {
      $rule->roles = unserialize($rule->roles);
      return $rule;
    }
    return FALSE;
  }
}

/**
 * Delete a skinr page rule object.
 */
function skinr_rule_delete($rid) {
  if ($rule = skinr_rule_load($rid)) {
    db_delete('skinr_rules')
      ->condition('rid', $rule->rid)
      ->execute();
    db_delete('skinr')
      ->condition('module', 'page')
      ->condition('sid', $rule->rid)
      ->execute();
  }
}

function skinr_rule_visible($rid) {
  global $user;

  if ($rule = skinr_rule_load($rid)) {
    $page_match = TRUE;

    if (!empty($record['roles']) && ($user->uid != 1) && !count(array_intersect(array_keys($user->roles), $rule->roles))) {
      return FALSE;
    }

    // Match path if necessary
    if ($rule->pages) {
      if ($rule->visibility < 2) {
        $path = drupal_get_path_alias($_GET['q']);
        // Compare with the internal and path alias (if any).
        $page_match = drupal_match_path($path, $rule->pages);
        if ($path != $_GET['q']) {
          $page_match = $page_match || drupal_match_path($_GET['q'], $rule->pages);
        }
        // When $rule->visibility has a value of 0, the item is displayed on
        // all pages except those listed in $rule->pages. When set to 1, it
        // is displayed only on those pages listed in $rule->pages.
        $page_match = !($rule->visibility xor $page_match);
      }
      else {
        // PHP.
        if (module_exists('php')) {
          $page_match = php_eval($rule->pages);
        }
      }
    }
    return $page_match;
  }
  return FALSE;
}

// ------------------------------------------------------------------
// Include file helpers.

/**
 * Load skinr files on behalf of modules.
 */
function skinr_module_include($file) {
  foreach (skinr_get_module_apis() as $module => $info) {
    $filepath = DRUPAL_ROOT . "/$info[path]/$module.$file";
    if (is_file($filepath)) {
      require_once $filepath;
    }
  }
}

/**
 * Get a list of modules that support skinr.
 */
function skinr_get_module_apis() {
  $cache = &drupal_static(__FUNCTION__, NULL);

  if (is_null($cache)) {
    $cache = array();
    foreach (module_implements('skinr_api') as $module) {
      $function = $module . '_skinr_api';
      $info = $function();
      if (isset($info['api']) && $info['api'] == 1.000) {
        if (!isset($info['path'])) {
          $info['path'] = drupal_get_path('module', $module);
        }
        $cache[$module] = $info;
      }
    }
  }

  return $cache;
}

// -----------------------------------------------------------------------
// Skinr data handling functions.

/**
 * Validate a skinr object.
 *
 * @param $skinr
 *   A skinr object.
 *
 * @return
 *   TRUE on success, FALSE on failure.
 */
function skinr_validate(&$skinr) {
  if (!isset($skinr->theme) || !isset($skinr->module) || !isset($skinr->sid) || !isset($skinr->skins)) {
    return FALSE;
  }
  if (!isset($skinr->settings)) {
    $skinr->settings = array();
  }
  if (!is_array($skinr->skins) || !is_array($skinr->settings)) {
    return FALSE;
  }

  // Strip empty skins.
  $skinr->skins = _skinr_array_strip_empty($skinr->skins);

  return TRUE;
}

/**
 * Save a skinr object.
 *
 * @param $skinr
 *   A skinr object.
 *
 * @return
 *   TRUE on success, FALSE on failure.
 */
function skinr_set($skinr) {
  // Make sure we're getting valid data.
  if (!skinr_validate($skinr)) {
    return FALSE;
  }

  if (empty($skinr->skins) && empty($skinr->settings)) {
    // Delete the db entry if it exists.
    db_delete('skinr')
      ->condition('theme', $skinr->theme)
      ->condition('module', $skinr->module)
      ->condition('sid', $skinr->sid)
      ->execute();
  }
  else {
    // Let's save the data.
    if (skinr_get($skinr->theme, $skinr->module, $skinr->sid) !== FALSE) {
      // Record exists, so let's update.
      drupal_write_record('skinr', $skinr, array('theme', 'module', 'sid'));
    }
    else {
      // Insert a new record.
      drupal_write_record('skinr', $skinr);
    }
  }

  return TRUE;
}

/**
 * Retrieves the desired skinr object.
 *
 * @return
 *   A skinr object if both $module and $sid are specified. An array of skinr
 *   objects if only $module is specified. An array of all skinr objects for a
 *   theme if neither $module nor $sid is specified. FALSE on failure.
 */
function skinr_get($theme = NULL, $module = NULL, $sid = NULL, $reset = FALSE) {
  $cache = &drupal_static(__FUNCTION__, array());

  if (is_null($theme)) {
    $theme = skinr_current_theme();
  }

  if (!isset($cache[$theme][$module][$sid])) {
    if (!isset($cache[$theme])) {
      $cache[$theme] = array();
    }
    if (!is_null($module) && !isset($cache[$theme][$module])) {
      $cache[$theme][$module] = array();
    }

    if (!is_null($module) && !is_null($sid)) {
      // Fetch just this sid.
      $result = db_query("SELECT theme, module, sid, settings, skins FROM {skinr} WHERE theme = :theme AND module = :module AND sid = :sid", array(
        ':theme' => $theme,
        ':module' => $module,
        ':sid' => $sid,
      ));
    }
    elseif (!is_null($module)) {
      // Fetch all settings for this theme and module.
      $result = db_query("SELECT theme, module, sid, settings, skins FROM {skinr} WHERE theme = :theme AND module = :module", array(
        ':theme' => $theme,
        ':module' => $module,
      ));
    }
    else {
      // Fetch all settings for this theme.
      $result = db_query("SELECT theme, module, sid, settings, skins FROM {skinr} WHERE theme = :theme", array(
        ':theme' => $theme,
      ));
    }

    foreach ($result as $skinr) {
      $skinr->settings = unserialize($skinr->settings);
      $skinr->skins = unserialize($skinr->skins);
      $cache[$skinr->theme][$skinr->module][$skinr->sid] = $skinr;
    }
  }

  if (is_null($sid) && is_null($module)) {
    // Return all the skinrs for the theme.
    if (isset($cache[$theme])) {
      return $cache[$theme];
    }
  }
  elseif(is_null($sid)) {
    // Return all the skinrs for the module.
    if (isset($cache[$theme][$module])) {
      return $cache[$theme][$module];
    }
  }
  elseif (isset($cache[$theme][$module][$sid])) {
    return $cache[$theme][$module][$sid];
  }
  return FALSE;
}

/**
 * Helper function to remove empty skins from an array.
 */
function _skinr_array_strip_empty($array) {
  $new_array = array();
  foreach ($array as $key => $value) {
    if (is_array($value)) {
      $value = _skinr_array_strip_empty($value);
    }
    if (!empty($value)) {
      $new_array[$key] = $value;
    }
  }
  return $new_array;
}

/**
 * Helper function to retrieve the current theme.
 * The global variable $theme_key doesn't work for our purposes when an admin
 * theme is enabled.
 *
 * @param $exculde_admin_theme
 *   Optional. Set to TRUE to exclude the admin theme from posible themes to
 *   return.
 */
function skinr_current_theme($exclude_admin_theme = FALSE) {
  global $user, $custom_theme;

  if (!empty($user->theme) && drupal_theme_access($user->theme)) {
    $current_theme = $user->theme;
  }
  elseif (!empty($custom_theme) && drupal_theme_access($custom_theme) && !($exclude_admin_theme && $custom_theme == variable_get('admin_theme', '0'))) {
    // Don't return the admin theme if we're editing skinr settings.
    $current_theme = $custom_theme;
  }
  else {
    $current_theme = variable_get('theme_default', 'garland');
  }
  return $current_theme;
}

/**
 * Prepare defaults for skins.
 *
 * @return
 *   An array of default skinset settings.
 */
function skinr_skins_default() {
  return array(
    'description' => '',
    'skinr' => array(),
  );
}

/**
 * Prepare defaults for skins.
 *
 * @return
 *   An array of default skins settings.
 */
function skinr_skin_default() {
  return array(
    'title' => '',
    'type' => 'checkboxes',
    'description' => '',
    'features' => array('*'),
    'templates' => array(),
    'options' => array(),
    'stylesheets' => array(),
    'scripts' => array(),
  );
}

/**
 * Retrieves all the Skinr skins from theme parents. Theme skins
 * will override any skins of the same name from its parents.
 */
function skinr_inherited_skins($theme) {
  $themes = list_themes();

  $all_skins = $skins = array();
  $base_theme = (!empty($themes[$theme]->info['base theme'])) ? $themes[$theme]->info['base theme'] : '';
  while ($base_theme) {
    $all_skins[] = (!empty($themes[$base_theme]->info['skinr'])) ? (array)$themes[$base_theme]->info['skinr'] : array();
    $base_theme = (!empty($themes[$base_theme]->info['base theme'])) ? $themes[$base_theme]->info['base theme'] : '';
  }
  array_reverse($all_skins);
  foreach ($all_skins as $new_skin) {
    $skins = array_merge($skins, $new_skin);
  }
  return $skins;
}

/**
 * Helper function to scan and collect skin .info data and their engines.
 *
 * @return
 *   An associative array of skins information.
 */
function _skinr_skins_data() {
  $cache = &drupal_static(__FUNCTION__, NULL);

  if (is_null($cache)) {
    // Find skins.
    $skins = drupal_system_listing('\.info$', 'skins');

    $defaults = skinr_skins_default();

    foreach ($skins as $key => $skinset) {
      $skins[$key]->info = drupal_parse_info_file($skinset->filename) + $defaults;

      // Invoke hook_skinr_info_alter() to give installed modules a chance to
      // modify the data in the .info files if necessary.
      // @todo: D7 Fix required!
      drupal_alter('skinr_info', $skins[$key]->info, $skins[$key]);
    }

    $cache = $skins;
  }

  return $cache;
}

/**
 * Helper function to process an skin or theme .info file.
 *
 * @return
 *    A skinset.
 */
function _skinr_skinset($info) {
  $skinset = FALSE;

  if (!empty($info->info['skinr'])) {
    $path_root = dirname($info->filename);
    $skinset = array(
      'options' => array(),
      'skins' => array(),
    );
    $info_skinr = (array)$info->info['skinr'];

    // Store skinr options.
    if (!empty($info_skinr['options'])) {
      $skinset['options'] = $info_skinr['options'];
      unset($info_skinr['options']);
    }

    // Inherit skins from parent theme, if inherit_skins is set to true.
    if (!empty($skinset['options']['inherit_skins'])) {
      $info_skinr = array_merge(skinr_inherited_skins($info->name), $info_skinr);
    }

    $defaults = skinr_skin_default();

    foreach ($info_skinr as $id => $skin) {
      if (!is_array($skin)) {
        continue;
      }
      $skinset['skins'][$id] = array(
        'title' => isset($skin['title']) ? $skin['title'] : $defaults['title'],
        'type' => isset($skin['type']) ? $skin['type'] : $defaults['type'],
        'description' => isset($skin['description']) ? $skin['description'] : $defaults['description'],
        'features' => isset($skin['features']) ? $skin['features'] : $defaults['features'],
        'templates' => isset($skin['templates']) ? $skin['templates'] : $defaults['templates'],
        'options' => isset($skin['options']) ? $skin['options'] : $defaults['options'],
        'stylesheets' => isset($skin['stylesheets']) ? $skin['stylesheets'] : $defaults['stylesheets'],
        'scripts' => isset($skin['scripts']) ? $skin['scripts'] : $defaults['scripts'],
      );

      // Give the stylesheets proper path information.
      $pathed_stylesheets = array();
      foreach ($skinset['skins'][$id]['stylesheets'] as $media => $stylesheets) {
        foreach ($stylesheets as $stylesheet) {
          $pathed_stylesheets[$media][$stylesheet] = $path_root .'/'. $stylesheet;
        }
      }
      $skinset['skins'][$id]['stylesheets'] = $pathed_stylesheets;

      // Give the scripts proper path information.
      $pathed_scripts = array();
      foreach ($skinset['skins'][$id]['scripts'] as $script) {
        $pathed_scripts[$script] = $path_root .'/'. $script;
      }
      $skinset['skins'][$id]['scripts'] = $pathed_scripts;
    }
  }

  return $skinset;
}

/**
 * Helper function to process an array of skins or themes .info files.
 *
 * @return
 *    An array of skinsets.
 */
function skinr_skinsets($skinsets) {
  $return = array();

  foreach ($skinsets as $info) {
    if ($skinset = _skinr_skinset($info)) {
      $return[$info->name] = $skinset;
    }
  }

  return $return;
}

/**
 * Themes are allowed to set Skinr styles in their .info files.
 *
 * @return
 *    An array of skinsets keyed by themename.
 *
 * @todo Use DB caching. No need to keep processing things every page load.
 */
function skinr_skin_data() {
  $cache = &drupal_static(__FUNCTION__, NULL);

  if (is_null($cache)) {
    $themes = list_themes();
    $skins_skinsets  = skinr_skinsets(_skinr_skins_data());
    $themes_skinsets = skinr_skinsets($themes);

    // Need to merge all skins skinsets into a single list of skins.
    $additional_skins = array();
    foreach ($skins_skinsets as $key => $skinset) {
      if (!empty($skinset['skins'])) {
        $additional_skins += $skinset['skins'];
      }
    }

    // Merge the additional styles into each theme, even if that theme has no
    // skinr data.
    foreach ($themes as $theme) {
      if ($theme->status != 1) {
        continue;
      }

      if (isset($themes_skinsets[$theme->name])) {
        $cache[$theme->name] = $themes_skinsets[$theme->name];
        $cache[$theme->name]['skins'] += $additional_skins;
      }
      else {
        $cache[$theme->name] = array(
          'options' => array(),
          'skins' => $additional_skins,
        );
      }
    }
  }

  return $cache;
}

/**
 * Fetch Skinr configuration data from modules.
 */
function skinr_fetch_config() {
  $cache = &drupal_static(__FUNCTION__, NULL);

  if (is_null($cache)) {
    $cache = module_invoke_all('skinr_config');
    foreach (module_implements('skinr_config_alter') as $module) {
      $function = $module . '_skinr_config_alter';
      $function($cache);
    }
  }

  return $cache;
}

/**
 * Fetch default configuration data for modules.
 */
function _skinr_fetch_config_defaults($setting) {
  switch ($setting) {
    case 'form':
      $data = array(
        'access_handler' => 'skinr_access_handler',
        'index_handler' => 'skinr_index_handler',
        'data_handler' => 'skinr_data_handler',
        'submit_handler' => 'skinr_submit_handler',
        'submit_handler_attach_to' => "['#submit']",
        'skinr_title' => t('Skinr'),
        'skinr_weight' => 1,
        'title' => '',
        'description' => t('Manage which skins you want to apply to this'),
        'collapsed' => TRUE,
        'weight' => 0,
      );
      return $data;
  }
}

/**
 * Execute a module's data handler.
 */
function skinr_handler($type, $op, $handler, &$a3, $a4 = NULL, $a5 = NULL, $a6 = NULL, $a7 = NULL) {
  if (is_callable($handler)) {
    switch ($type) {
      case 'contextual_links':
      case 'preprocess_index_handler':
        return $handler($a3);
      case 'preprocess_hook_callback':
        return $handler($a3, $a4);
      case 'data_handler':
      case 'submit_handler':
        return $handler($a3, $a4, $a5, $a6, $a7);
      default:
        return $handler($op, $a3, $a4);
    }
  }
}